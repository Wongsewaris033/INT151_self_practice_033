shallowEquality: จะเป็นการเปรียบเทียบในระดับบนๆ เช่น
- ถ้าค่าเป็นชนิดพื้นฐาน (number, string, boolean, null, undefined, symbol) จะเทียบตรง ๆ ด้วย ===
- ถ้าค่าเป็นObject/Array/Function จะเทียบ “reference” เท่านั้น ไม่ดูinfoภายใน
- ลำดับkeys ไม่กระทบกับตัวผลลัพธ์
- ใช้ === ทำให้ 123 ไม่เท่ากับ "123" เพราะเป็นคนละ type กัน
- ค่า NaN ทั้งสองตัวจะไม่เท่ากันใน === (เนื่องจาก NaN === NaN เป็น false) //  ถ้าอยากให้ NaN เท่ากัน ต้องใช้ Object.is(a, b) แทน ===

--------------------

(1.1)
true เนื่องจากshallowEquality ไม่สนลำดับ สนใจแค่ค่าคีย์ด้านใน

(1.2)
false เพราะtype ของb ไม่เหมือนกัน
y1: b มีค่าเป็นNum และ y1: b มีค่าเป็นString โจทย์ให้เปรียบเทียบโดยใช้ === เมื่อเช็คtypeและทำให้เป็น false

(1.3)
false เพราะในjs NaN === NaN มีค่าเป็น false

(1.4)
false เพราะแต่ละตัวแปรจะเก็บค่าคีย์ของตัวมันเอง เหมือนที่อาจารย์บอกในห้องคือแต่ละตัวก็ต่างคนต่างเก็บแต่ว่าแค่มันมีสิ่งที่ใส่เข้าไปเหมือนกันเฉยๆ (Objซ้อน แต่คนละreference)

--------------------

function shallowEqualityFixed(a, b) {
  const k1 = Object.keys(a)
  const k2 = Object.keys(b)
  if (k1.length !== k2.length) return false
  for (const key of k1) {
    if (!Object.is(a[key], b[key])) return false
  }
  return true
}

ปกติแล้ว NaN === NaN จะได้ false เสมอ โดยผมจะใช้ Object.is
Object.is(NaN, NaN) -> true
Object.is ยังสามารถแยก (+0,-0) ได้ซึ่งปกติแล้วถ้าใช้ === มันจะมองว่าเท่ากันแต่ Object.is จะมองว่าอันนึงเป็น pos อีกอันเป็น neg
การเปลี่ยนจาก === เป็น Object.is ใน shallowEquality จะทำให้ (NaN เท่ากับ NaN // การเปรียบเทียบ primitive ทำงานเหมือน === เกือบทั้งหมด // ได้ผลลัพธ์มากขึ้นในเคสพิเศษ เช่น Nan,+0,-0)

--------------------

แต่ละตัวแปรจะเก็บค่าคีย์ของตัวมันเอง เหมือนที่อาจารย์บอกในห้องคือแต่ละตัวก็ต่างคนต่างเก็บแต่ว่าแค่มันมีสิ่งที่ใส่เข้าไปเหมือนกันเฉยๆ (Objซ้อน แต่คนละreference)
=== ของObjectจะเทียบ reference ไม่ใช่infoภายใน แม้โครงสร้างและค่าด้านในเหมือนกัน แต่เป็นคนละObject